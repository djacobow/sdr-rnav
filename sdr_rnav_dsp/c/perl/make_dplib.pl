#!/usr/bin/perl -w

# Author: David Jacobowitz
#         david.jacobowitz@gmail.com
#
# Date  : Spring 2014
#
# Copyright 2014, David Jacobowitz

# This script creates dplib.pm, which is a perl-based interface
#  to the dp dsp library, originally written for the SDR-RNAV
#  project.
#
# dplib.pm is auto-generated primarily because it makes everything
#  easier and it makes Inline::C less confused about whether it needs
#  to recompile or not.

# It wraps every function exported by the "dplib.dll" dll. 
# Moreover, by default every function that starts with dp_ will
# be EXPORTED. None of these functions know anything about perl,
# so they have very c-ish interface that are not perl friendly.
# Functions in helpers.c have routines that allow perl to access
# the relevant datastructures where necessary.

use warnings qw(all);

use File::Slurp;
use Exporter qw(import);
use Data::Dumper;
use Cwd;

my $output_name = 'dplib.pm';

# All the dplib header files:
my @h_files = getLibHeaderList();

my $extradirs = getExtraDirs();

# The file "helpers.cpp" is not complete. It contains anchor
# placeholders for routines to read out the data structs
# that hold certain dsp result state into a perl-palatable form.
# This variable tells what placeholders to search for and what
# to replace them with,.
my $structs = {
 "../dp/dp_findpeaks.h" => {
  type_name => 'peak_pts_t',
  var_name => 'ppts',
 },
};
makeHashConverters($structs);

# Inline::C cannot process more than one file, so I load a
# bunch of C files here and cat them together. Also,
# because the dp library abuses the preprocessor, I need
# to expand some macros in advance so that the Inline::C
# processor can see the unmacroized versions. However, I
# don't want to get the full macro preprocessor output 
# because that will pull garbage in to the library that we 
# don't need. So this file includes its own 1/2 baked 
# macro preprocessor that can read in a bunch of macros 
# and only replace ones that match a certain pattern -- 
# in this case starting with DP_

# all the header files whose declarations we want
my $all_h   = loadCPPdata(@h_files);

# these files contain the macros we want to replace
my $base_h  = loadCPPdata("../dp/dp_base.h",
                          "../dp/dp_base_internals.h",
                          "../dp/dp_pl_sharelist.h");

# some additional files that have c code that we want
my $helpers = loadCPPdata('helpers.c',"../src/rstat_pl_access.c");
my $macros = findMacrosMatching($base_h,'DP_');

# some macros use other macros and replaceMacros is not 
# recursive, so I call it 2x.
my $r1_h = replaceMacros($all_h,$macros);
my $r2_h = replaceMacros($r1_h,$macros);
$helpers = replaceMacros($helpers,$macros);

# finally cat all the headers and c code together
# and insert the struct-to-hash converters where 
# placeholders exist
$r2_h .= $base_h;
$r2_h .= $helpers;
$all_h = insertHashConverters($structs,$r2_h);

# only export to perl the functions that are of interest to 
# the perl world, which I have all named with the same 
# start
my @funcs_to_export = findFuncs("dp_", $r2_h);

my $funcs_to_export_str = "our \@EXPORT = qw(\n";
$funcs_to_export_str .= '   ' . join("\n   ",@funcs_to_export);
$funcs_to_export_str .= ");\n";

my $today = scalar localtime time;

my $out_string = << "__END_OF_HERE";
#!/usr/bin/perl -c

# ## DO NOT EDIT ########################################
#
# This is the dplib perl module, which wraps all the C 
# goodness the the "dp" dsp library to be callable from 
# perl.
#
# This file was auto-generated by $0
#
# on $today.
#
# If you need to make changes, edit the file above.
#
# ## DO NOT EDIT ########################################
#
#
# Author: David Jacobowitz
#         david.jacobowitz@gmail.com
#
# Date  : Spring 2014
#
# Copyright 2014, David Jacobowitz

# 
package dplib;

use warnings qw(all);
use Exporter qw(import);
use Data::Dumper;

$funcs_to_export_str;

use Inline C => Config => 
 LIBS => "$extradirs->{l_path} -ldp -lrtlsdr -lpthread",
 CCFLAGS => "-g -O0 -fno-omit-frame-pointer",
 INC => "$extradirs->{inc_path}",
 MYEXTLIB => "$extradirs->{l_f_path}",
 ENABLE => "AUTOWRAP",
 OPTIMIZE => '-g -O0',
 TYPEMAPS => 'typemap';

use Inline C;
Inline->init;

1;

__DATA__
__C__
$all_h
__END_OF_HERE


my $ofh = undef;
open($ofh,'>',$output_name) or 
  die "could not open output file $output_name\n";
print $ofh $out_string;
close $ofh;















# --------------------------------------------------------
# -- done --
# -- no user serviceable parts below here --


# returns a list of things in a c file that look like 
# function names.
sub findFuncs {
 my $pat = shift;
 my $is  = shift;
 my $fh = undef;
 my @list = ();
 foreach my $l (split(/\n/,$is)) {
  my @ps = split(/[\s\*]/,$l);
  foreach my $p (@ps) {
   if ($p =~ /($pat\w+)\s*\(/) {
    push(@list,$1);
   }
  }
 }
 return @list;
};

# load a bunch of files together into one long string
sub loadCPPdata {
 my @files = @_;
 my $all_cpp = '';
 foreach my $file (@files) {
  $all_cpp .= "\n\n" . read_file($file);
 }
 return $all_cpp;
};

# routine can find a reference to a certain struct and, if the 
# header file is formatted properly, read in the name and type
# of each member of the struct and create Perl XS code to 
# convert the struct to a Perl hash.
#
# Does not do arrays, does not do deep structures -- though it 
# could be expanded to be more general, I suppose.
sub makeHashConverters {
 my $files = shift;
 foreach my $file (keys %{$files}) {
  my $tname = $files->{$file}{type_name};
  my $vname = $files->{$file}{var_name};
  $files->{$file}{repl_string} = '';
  my $fh;
  my $in_struct = 0;
  open($fh,'<',$file) or die "could not open $file\n";;
  while (<$fh>) {
   my $il = $_; chomp $il;
   #print "tname $tname\n";
   if ($il =~ /typedef struct\s$tname/) {
    $in_struct = 1;
   } elsif ($il =~ /\}.*$tname/) {
    $in_struct = 0;
   } elsif ($in_struct) {
    if ($il =~ /(\w+)\s+(\w+);/) {
     my $type = $1;
     my $var  = $2;
     my $makesvstr = '';
     if ($type eq 'float') {
      $makesvstr = "newSVnv($vname" . "->" . "$var)";
     } elsif ($type eq 'double') {
      $makesvstr = "newSVnv($vname" . "->" . "$var)";
     } elsif ($type eq 'dp_bool_t') {
      $makesvstr = "newSViv($vname" . "->" . "$var)";
     } elsif ($type =~ /int/) {
      $makesvstr = "newSViv($vname" . "->" . "$var)";
     }
     if (length($makesvstr)) {
      $files->{$file}{repl_string} .=  << "_end_of_repl_here";
      hv_stores(hash,"$var",$makesvstr);
_end_of_repl_here
     }
    }
   }
  }
  close $fh;
 }
};

# This routine actually puts the getters formed above into
# the c file slurped together above
sub insertHashConverters {
 my $files = shift;
 my $cpp_data = shift;
 foreach my $file (keys %{$files}) {
  my $vn = $files->{$file}{var_name};
  my $d  = $files->{$file}{repl_string};
  my $new_cpp_data = '';
  my @cpp_lines = split(/\n/,$cpp_data);
  foreach my $l (@cpp_lines) {
   if ($l =~ /___PERL_INSERT_HASH_COPYING_$vn/) {
     $new_cpp_data .= $d
   } else {
     $new_cpp_data .= $l . "\n";
   }
  }
  $cpp_data = $new_cpp_data;
 }
 return $cpp_data;
};


# The homebrew C preprocessor in this library has two pieces. The 
# first will takes a stringified file and a pattern and try to 
# find all the macros that match it. Macros can take multiple 
# arguments but extra spaces will confuse it. The result of this 
# routine is a structure holding the macros.
sub findMacrosMatching {
 my $is = shift;
 my $pat = shift;

 my @lines = split(/\n/,$is);

 my $macros = {};
 my $mname = '';
 my @margs = ();
 my $mbody = '';
 my $complete = 1;

 foreach my $l (@lines) {
  chomp $l;
  if ($complete) { 
   if ($l =~ /#define\s+($pat\w+)(.*)$/) {
    $mname = $1;
    @margs = ();
    $mbody = $2;
    if ($l =~ /#define\s+($pat\w+)\(([\w,]+)\)(.*)$/) {
     my $astring = $2;
     @margs = split(/,/,$astring);
     $mbody = $3;
    }
    if ($mbody =~ /\\\s*$/) {
     $complete = 0;
    }
   }
  } else {
   $mbody .= $l;
   if ($l !~ /\\\s*$/) {
    $complete = 1;
   }
  }

  if ($complete) {
   my @m_c = @margs;
   $mbody =~ s/\\/\n/g;
   $macros->{$mname} = {
    args => \@m_c,
    body => $mbody,
   };
   @margs = ();
   $mname = '';
   $mbody = '';
  };
 }
 #print Dumper $macros;
 return $macros;
};


# second half of the C preprocessor, uses the macros 
# returned from the function above to replace intances in the 
# stringified file provided. Returns de-macroized stringified
# files.
sub replaceMacros {
 my $is     = shift;
 my $macros = shift;
 my $os     = '';
 delete $macros->{''};
 my ($before, $after) = ('','');

 my @ls = split(/\n/,$is);
 foreach my $l (@ls) {
  if ($l !~ /#define|#ifndef/) {
   foreach my $mname (keys %$macros) {
    # print "mname $mname l $l\n";
    if ($l =~ /^(.*)$mname(\(([\w,\s\*]+)\))?(.*)$/) {
     $before = $1;
     $after  = $4;
     my $args = defined($3) ? $3 : '';
     my @margs = split(/,/,$args);
     @margs = map { $_ =~ s/^\s+//; $_ =~ s/\s+$//; $_; } @margs;
     #print "name $mname ==  args " . join(', ',@margs) . "\n";
     my @b_pieces = split(/(\W+)/,$macros->{$mname}{body});
     my $repls = {};
     for (my $i=0;$i<@margs;$i++) {
      $repls->{ $macros->{$mname}{args}[$i] } = $margs[$i];
     }
     my @b_repld = ();
     foreach my $b_piece (@b_pieces) {
      my $repl_piece = defined($repls->{$b_piece}) ? 
                               $repls->{$b_piece} : $b_piece;
      if ($repl_piece =~ /\s*##\s*/) {
       $repl_piece = '';
     }
      push(@b_repld, $repl_piece);
     };
     # print "BEFORE: $l\n";
     $l = $before . join('',@b_repld) . $after;
     # print "AFTER : $l\n";
    }
   }
  }
  $os .= $l . "\n";
 }
 return $os;
};

sub getLibHeaderList {
 my $h_hash = {};
 map { $h_hash->{$_} = 1; } glob "../dp/dp_*.h";
 delete $h_hash->{'../dp/dp_base.h'};
 delete $h_hash->{'../dp/dp_base_internals.h'};
 if ($^O ne 'linux') {
  delete $h_hash->{'../dp/dp_linaudio.h'};
 }

 my @h_list = keys %$h_hash;
 return ('flags.h', @h_list, '../dp/_dp_ctors.h');
 return sort keys %$h_hash;

};


sub getExtraDirs {

 my $pwd = getcwd; chomp $pwd;
 my @idirs     = qw( ../dp  ../inc
                     ../src ../dp/kiss_fft130
                    .);
 my @ldirs = ("/../dp");
 my @lfiles = ();
                   
 if ($^O eq 'MSWin32') {
  push(@idirs,  "../../rtl_tools");
  push(@ldirs,  "../../rtl_tools/Win32");
  push(@lfiles, "/../dp/dp.dll");
 } else {
  push(@lfiles, "/../dp/libdp.so.0");
 }
 
 my $inc       = join(" ", map { "-I" . $pwd . '/' . $_ . '/'; } @idirs);
 my $l_path    = join(" ", map { "-L" . $pwd . '/' . $_; } @ldirs);
 my $l_f_path .= join(" ", map { $pwd . '/' . $_; } @lfiles);
 $l_path   .= " -LC:/strawberry/c/bin ";

 print "===== dplib Inline::C build parameters ====\n";
 print "  l_path   : \t$l_path\n";
 print "  l_f_path : \t$l_f_path\n";
 print "  inc      : \t$inc\n";
 print "===== ================================ ====\n\n\n";

 return {
   inc_path => $inc,
   l_path   => $l_path,
   l_f_path => $l_f_path,
 };
}


1;

